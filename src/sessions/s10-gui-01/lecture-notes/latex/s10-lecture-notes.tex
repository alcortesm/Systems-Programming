\documentclass[a4paper, 9pt]{extarticle}

\usepackage[notes]{style}

\newcommand{\realtitle}{Session 10 - GUI 01}

\begin{document}

\makebox[\linewidth]{\rule{\textwidth}{0.4pt}}
UC3M \hfill Alberto Cortés Martín\\
Systems Programming, 2014-2015 \hfill version: \today\\
\makebox[\linewidth]{\rule{\textwidth}{0.4pt}}
\begin{center}
  \Large{\realtitle}\\Lecture Notes
\end{center}
\makebox[\linewidth]{\rule{\textwidth}{0.4pt}}
\vspace{1cm}


\section{Today's Topics}
\begin{blackboard}
Functors, Nested classes & Anonymous classes
GUIs
\end{blackboard}







\section{Classes we are going to use today}

Today we are going to use the Java Runnable interface in our examples:

\begin{multicols}{2}
  \begin{center}
    \verb+runnable.eps+\\
    \includegraphics[width=5cm]{./img/runnable/runnable.eps}
  \end{center}
  \columnbreak
  \begin{blackboard}
interface Runnable {
    public void run();
}
\end{blackboard}
\end{multicols}
















\section{Funtors}


Let's write a simple program that prints "Hello":

\codeinput{../java/Hello1.java}{Hello1.java}

Now let's write another version of this same program:

\codeinput{../java/Hello2.java}{Hello2.java}

We have hide what we want to do inside a method and call that method instead.

Now let's write another, more complicated version of this program:

\begin{multicols}{2}
  \codeinput{../java/Hello3.java}{Hello3.java}
  \columnbreak
  \codeinput{../java/PrintFunctor.java}{PrintFunctor.java}
\end{multicols}

We have hide what we want to do inside an object, and then call the run()
method of that object.

This seems like a very complicated way to something very simple, and you are
right, but stay with me for a minute.

Whenever you want to print "Hello" you can create an object from this class
and call its \verb+run()+ mehtod.

The sole purpuse in life of this class is to carry what we want to do, and then
do it when we call its run method.

This class is just what we want to do, disguised as an object.

This class is called a FUNCTOR, a bunch of code disguised as an object.

Funtors are very important because you can not pass code or methods, but you can pass objects.

For example:

Let's say we have a program that prints 10 times "hello" and adds 10 times
"Alberto" to an \verb+ArrayList<String>+.

You can do that by hand, or create a method that runs an object 10 times and
then you call that method two times: first with a functor that prints "hello",
then with a functor that adds "Alberto" to an \verb+ArrayList<String>+.

The conceptual jump is huge, you are no longer creating methods that does
something, you are creating methods that do "anything" you want to do.




\subsection{Nested Classes}

Now, in Java there is yet a better way to do this.

As you are only going to use the PrintFuntor class to create a single object,
pass it to a method and then forget about it, creating a PrintFunctor.java
files seems like an overkill.

It is not a very important class, you are only going to use it once to create a
single object and then you forget about it.

In Java, you can create classes inside another class, they are called NESTED
CLASSES.

So instead of creating a new java file for this class, you can simply write
this class inside the class that is going to use it.

\codeinput{../java/Hello4.java}{Hello4.java}




\subsection{Anonymous Classes}

Now, in Java there is even a better way to do that.

You don't even have to create a nested class, you can just write the class in
the same line where you are creating an object from that class.

An anonymous class is how you create an object from a class that you only need
for that single object, and then you forget about it forever.

In spanish there is a perfect way to describe them: "una clase anónima es una
clase de usar y tirar".

The best english translation I have found for this is, anonymous classes are
"one use classes" or "disposable classes".

You use them once to create a single object and then you throw them away.

For example, if you need an object that implements the Runnable interface, and
that prints hello when you call its run method, you can write something like this:

\codeinput{../java/Hello5.java}{Hello5.java}





















\section{GUIs}

Let's run a program that prints the prime numbers smaller than its argument:

\verb+ DEMO: java PrimesTui+

Now let's run a Graphical program that does the same:

\verb+ DEMO: java PrimesGui+

Let's talk about their similarities and differences:

\paragraph{Similarities}

\begin{itemize}

  \item They have the same functionality.

    In fact, the core of both programs is the same, a class that calculates
    prime numbers, only 35 loc.

\end{itemize}

\paragraph{Differences}

\begin{itemize}

  \item The GUI version is much complex:

    \begin{itemize}

      \item PrimeTui.java is 17 loc, PrimesGui.java is 151 loc.

      \item PrimeTui uses 3 classes: String and 2 Exceptions. But PrimesGui
        uses 12 classes, 2 interfaces and defines 2 nested classes, 4 functors
        and 4 anonymous classes.

    \end{itemize}

\end{itemize}



\end{document}

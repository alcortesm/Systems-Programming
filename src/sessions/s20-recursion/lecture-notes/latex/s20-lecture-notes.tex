\documentclass[a4paper, 9pt]{extarticle}

\usepackage[notes]{style}

\newcommand{\realtitle}{Session 20 - Recursion}

\begin{document}

\makebox[\linewidth]{\rule{\textwidth}{0.4pt}}
UC3M \hfill Alberto Cortés Martín\\
Systems Programming, 2014-2015 \hfill version: \today\\
\makebox[\linewidth]{\rule{\textwidth}{0.4pt}}
\begin{center}
  \Large{\realtitle}\\Lecture Notes
\end{center}
\makebox[\linewidth]{\rule{\textwidth}{0.4pt}}
\vspace{1cm}


\section{Today's Topics}
\begin{blackboard}
Recursion
\end{blackboard}


\section{The Concept}

In mathematics, the factorial of a nonnegative integer is calculated as follows:

\begin{multicols}{2}
\begin{equation*}
  n! =
  \begin{cases}
    1, & \text{if } n = 0\\
    \prod_{i=1}^{n}i, & \text{otherwise}
  \end{cases}, \forall n \in \mathbb{Z}^{*}.
\end{equation*}

\columnbreak

\begin{center}
  \begin{tabular}{|l|l|r|}
    \hline
    $n$ & calculation & $n!$\\
    \hline
    0   & $1$          & 1 \\
    1   & $1$          & 1 \\
    2   & $1 \cdot 2$ & 2 \\
    3   & $1 \cdot 2 \cdot 3$ & 6 \\
    4   & $1 \cdot 2 \cdot 3 \cdot 4$ & 24 \\
    5   & $1 \cdot 2 \cdot 3 \cdot 4 \cdot 5$ & 120 \\
    \ldots & \ldots & \ldots \\
    \hline
  \end{tabular}
\end{center}
\end{multicols}

This is, $n!$ is the product of all the natural numbers from 1 to $n$ and $0!$ is 1.


ASK THE STUDENTS TO WRITE A PROGRAM: write a program that calculates the factorial of a number.

\begin{blackboard}
$ java Factorial 0
1
$ java Factorial 1
1
$ java Factorial 2
2
$ java Factorial 3
6
$ java Factorial 4
24
$ java Factorial 5
120
...
\end{blackboard}


You probably wrote an \emph{iterative} version of the program, this is, a program that \emph{iterates}, this is, a program that uses a loop.

Something like this:

\codelinesinput{../java/FactorialIterative.java}{FactorialIterative.java}{1}{36}


But there is \emph{another} definition of the factorial:
\begin{multicols}{2}
\begin{equation*}
  n! =
  \begin{cases}
    1,              & \text{if } n = 0\\
    n(n-1)!,    & \text{otherwise}
  \end{cases}, \quad \forall n \in \mathbb{Z}^{*}.
\end{equation*}

\columnbreak

\begin{center}
  \begin{tabular}{|l|l|r|}
    \hline
    $n$ & calculation & $n!$\\
    \hline
    0   & $1$          & 1 \\
    1   & $1 \cdot 0!$ & 1 \\
    2   & $2 \cdot 1!$ & 2 \\
    3   & $3 \cdot 2!$ & 6 \\
    4   & $4 \cdot 3!$ & 24 \\
    5   & $5 \cdot 4!$ & 120 \\
    \ldots & \ldots & \ldots \\
    \hline
  \end{tabular}
\end{center}
\end{multicols}

In math, this is called a \emph{recursive} definition, as the definition of the factorial uses the factorial itself.

You have already seen some recursive definitions in Java, for example a \verb+Node<E>+ has an attribute \texttt{next} of type \verb+Node<E>+.

According with this new definition of the factorial, we can write an
alternative version of the \verb+factorial+ method above:

\codelinesinput{../java/FactorialRecursive.java}{FactorialRecursive.java}{29}{35}

This method is shorter and simpler to understand than the previous one, as it
directly mirrors the mathematical definition.

In programming, this is called a \emph{recursive} method, this is a method that calls itself.





\section{Recursion and the Stack}

Let us see what is happening in the stack while the \texttt{FactorialRecursive} program is running:

\begin{blackboard}
$ java FactorialRecursive 3
6
$ java FactorialRecursiveVerbose 3
calling fact(3)
|  calling fact(2)
|  |  calling fact(1)
|  |  |  calling fact(0)
|  |  |  returning 1
|  |  returning 1
|  returning 2
returning 6
6
\end{blackboard}

DIBJAR MEMORIA DURANTE LA EJECUCIÓN




\section{Anatomy of a recursive call}

A recursive call must have two sections:

\begin{itemize}

\item one or more \emph{base cases}: returns a direct solution to the problem
  without using recursion.

\codelinesinput{../java/FactorialRecursive.java}{FactorialRecursive.java}{30}{31}

\item one or more \emph{recursive cases}: reduces the problem by doing some
  operations over a \emph{simplified} version of the problem.

\codelinesinput{../java/FactorialRecursive.java}{FactorialRecursive.java}{32}{33}

\end{itemize}

Without a base case you will have infinite recursion, as the recursive method
will call itself forever.

Without a recursive case, you will not have recursion at all.

It is important that the recursive case calls a simplified version of the
problem, this is, you have to eventually get to the base case throwout your
recursive calls, otherwise you will be making the problem bigger and bigger
instead of simplifiying it and the recursion will never reach the base case.




\section{Can you solve any problem using recursion}

Nobody knows, this is still an open problem, but \emph{it is belived} among the
scientific comunity that

\begin{blackboard}
Any problem on natural integers that can be solved using
iteration, can be solved using recursion, and the other way around.
\end{blackboard}

This is call the ``Church-Turin thesis'', due to Alonso Church and Alan Turin.

It has been proved that this thesis cannot be proved, but most programmers
believe it is true (me included).






\section{Recursion or iteration}

Even if you believe in the Church-Turin thesis, not all problems are the same.

\begin{center}
  \includegraphics[width=8cm]{./img/recur-vs-iter/recur-vs-iter.eps}
\end{center}

There are some problems that are easier to solve using an iterative approach,
and there are problems that are easier to solve using a recursive approach.

Sadly there is no way to know to what group your problem belongs, so you will
need some intuition and imagination to decide between working on an iterative
solution or a recursive one.

Then even if you get it right, maybe the other solution is more efficient in
terms of memory or execution time.

So chosing between iteration or recursion is more an art than a science.





\section{Tips on solving problems using recursion}

The trick is:

\begin{blackboard}
Realize that your problem is just some operations over a simpler version of the
same problem.
\end{blackboard}

Of course this is not always easy, but some times, it is, for example the factorial:

\begin{equation*}
  n! =
  \begin{cases}
    1,              & \text{if } n = 0\\
    n(n-1)!,    & \text{otherwise}
  \end{cases}, \quad \forall n \in \mathbb{Z}^{*}.
\end{equation*}

Instead of solving the factorial of $n$, you perform some operations on the
factorial of $(n-1)$, that is a simpler version of the problem, as you will
eventually reach the base case of $0! = 1$, which is the most simple case.




\section{More Examples of recursion}

Let us see more examples of recursive methods:


\subsection{Counting from N to 1}

\begin{multicols}{2}
  \codelinesinput{../java/CountNTo1Iterative.java}{CountNTo1Iterative.java}{24}{28}
\columnbreak
  \codelinesinput{../java/CountNTo1Recursive.java}{CountNTo1Recursive.java}{24}{29}
\end{multicols}

Counting from $N$ to 1 is just printing $N$ and then counting from $N-1$ to 1.

The base case is just when we reach 1: we do nothing (except for printing the 1).

\subsection{Counting from 1 to N}

\begin{multicols}{2}
  \codelinesinput{../java/Count1ToNIterative.java}{Count1ToNIterative.java}{24}{28}
\columnbreak
  \codelinesinput{../java/Count1ToNRecursive.java}{Count1ToNRecursive.java NOT IN THE HANDOUT}{24}{29}
\end{multicols}

This is quite interesting, just changing when we print the message we are
printing backguards.

This is because the stack frames for the methods live inside a stack, and as
you know an stack reverse the order of its elements.

You will be able to understand this better with a verbose version of the programs:

\newpage

\begin{multicols}{2}
  \begin{blackboard}
$ java CountNTo1Recursive 5
5
4
3
2
1
$ java CountNTo1RecursiveVerbose 5
calling countNTo1(5)
5
|  calling countNTo1(4)
4
|  |  calling countNTo1(3)
3
|  |  |  calling countNTo1(2)
2
|  |  |  |  calling countNTo1(1)
1
|  |  |  |  returning
|  |  |  returning
|  |  returning
|  returning
returning
\end{blackboard}
\columnbreak
  \begin{blackboard}
$ java Count1ToNRecursive 5
1
2
3
4
5
$ java Count1ToNRecursiveVerbose 5
calling countNTo1(5)
|  calling countNTo1(4)
|  |  calling countNTo1(3)
|  |  |  calling countNTo1(2)
|  |  |  |  calling countNTo1(1)
1
|  |  |  |  returning
2
|  |  |  returning
3
|  |  returning
4
|  returning
5
returning
\end{blackboard}
\end{multicols}



\subsection{Palindromes}

PARA EJERCICIOS METER LA OPTIMIZACIÓN DE NO COPIAR ARRAYS.

\subsection{Finding the greater common divisor}

ESTE MEJOR PARA EJERCICIOS.


\subsection{Fibonacci}


\subsection{Linked Lists}


\section{Recursion Optimizations}



\subsection{Stack Overflows}

USE A BIGGER STACK (count1toN)

OR

USE TAIL RECURSION OPTIMIZATION (count1toN)

\subsection{Exponential growth}

USE MEMOIZATION

(fibonacci)




\subsection{Mutual recursion}

\end{document}
